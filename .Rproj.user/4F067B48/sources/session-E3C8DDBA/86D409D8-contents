
# Choix de seuils
#
# on pose  s la variable du veritable seuil du sujet
# plus s est bas (concentration de detection), plus le sujet sera sensible.
# on pose le vecteur S = [s0, s1, ... , sK] un vecteur de seuils limites, avec s0=0<s1<...<sk
# tels que I0=[s0=0, s1[ contient les personnens les plus sensibles et Ik=[sk, Inf[ contient les moins sensibles
#
# On considere l'experience suivante: on teste les seuils (e partir de s1: on a donc K experiences)
# dans l'ordre decroissant.
# On mesure le rang de l'exp?rience ou on a echoue. On note la variable aleatoire
# T= seuil observe = K si on echoue des la premiere experience
# T= 0 si on reussit tous les tests
#
# Consid?rons le cas ou un sujet est extremement sensible: il reussira tous les tests sans recourir au hasard
# P(T|s in I0) :  P(T=0|s in I0)=1 et  pour tout k,  P(T=k|s in I0)=0
#

# Considerons le cas ou un sujet n'est pas du tout sensible il repondra aleatoirement a tous les tests
# Supposons qu'il ait une probabilit? p = 7/8 d'echouer au test (et donc q=1-p=1/8 de le reussir) en repondant au hasard
# Alors,
# P(T=0|s in IK)= q^K et  pour tout k<K,  P(T=k|s in I0)=pq^k
# P(T|s in IK) suit une loi geometrique tronquee de parametres n=K et p=p

# Consid?rons le cas intermediaire ou un sujet a un seuil qui appartient a Ij
# Alors, il reussira tous les tests jusqu'a s_j (c'est a dire qu'il reste j epreuves a faire), et il repondra au hasard sur les K-j autres tests
# Avec k>j, P(T=k|s in Ij)=0
# Pour k <=j, P(T=k|s in Ij) suit une loi g?om?trique tronqu?e de parametre n=j et p=p
#

# on note
# - k la valeur de T prise (seuil observe)
# - j l'indice de l'intervalle du seuil theorique, p la probabilite d'echouer au test par hasard,
# K le nombre de tests
probaTsachantS=function(Tk,Sj,p,eps=0,K=NULL, modelEps="last")
{
   #eps est la probabilité de se tromper si le seuil théorique est inférieur à j (il parait que ça arrive...)
  if(modelEps!="none")
  {
    correctionEps=1-eps
    if(Sj==K){correctionEps=1}
  }
  else{correctionEps=1}

  if(Tk>Sj)# si le seuil observe est plus haut (+concentre) que le seuil theorique: proba = 0
    {
      if(modelEps=="none")
      {
        proba=0
      }
      if(modelEps=="last")
      {
        if(Tk==Sj+1)
        {
          proba=eps
        }
        else
        {
          proba=0
        }
      }
      # if(modelEps=="equi")
      # {
      #   proba=eps/(K-Sj+1)
      # }
  }

    if(Tk==Sj)
    {
      if(Sj==0){proba=correctionEps}else{proba=p*correctionEps}
    } #la proba de se tromper ? partir de l? est de 7/8 (doit etre inclus ci dessous)

    if(Tk<Sj)
    {
          q=(1-p)
          proba=correctionEps*p*q^(Sj-Tk) # la proba de se tromper sur les j derniers termes suit une loi g?om?trique tronqu?e de parametre n=j
          if(Tk==0){proba=correctionEps*q^Sj} #la proba de ne pas faire du tout d'erreur  sur les tests restants est q^j
    }
 # }
  return(proba)
}
# verif modèle usuel (sans epsilon)
probaTsachantS(Tk=0,Sj=0,p=7/8,K=3)==1
probaTsachantS(Tk=1,Sj=0,p=7/8,K=3)==0
probaTsachantS(Tk=2,Sj=0,p=7/8,K=3)==0
probaTsachantS(Tk=0,Sj=1,p=7/8,K=3)== 1/8
probaTsachantS(Tk=1,Sj=1,p=7/8,K=3)== 7/8
probaTsachantS(Tk=2,Sj=1,p=7/8,K=3)== 0
probaTsachantS(Tk=0,Sj=2,p=7/8,K=3)== 1/(8*8)
probaTsachantS(Tk=1,Sj=2,p=7/8,K=3)==7/64
probaTsachantS(Tk=2,Sj=2,p=7/8,K=3)==7/8
probaTsachantS(Tk=0,Sj=3,p=7/8,K=3)== 1/(8^3)
probaTsachantS(Tk=1,Sj=3,p=7/8,K=3)==1/(8^2)*(7/8)
probaTsachantS(Tk=2,Sj=3,p=7/8,K=3)== 1/(8)*(7/8)
probaTsachantS(Tk=3,Sj=3,p=7/8,K=3)== 7/8
probaTsachantS(Tk=3,Sj=0,p=7/8,K=3)== 0
probaTsachantS(Tk=4,Sj=4,p=7/8,K=3)== 7/8
probaTsachantS(Tk=3,Sj=1,p=7/8,K=3) == 0
probaTsachantS(Tk=3,Sj=2,p=7/8,K=3) == 0
probaTsachantS(Tk=0,Sj=8,p=7/8,K=3) == 1/(8^8)
probaTsachantS(Tk=8,Sj=8,p=7/8,K=3) ==7/8
probaTsachantS(Tk=8,Sj=9,p=7/8,K=3) ==7/8*(1/8)
probaTsachantS(Tk=9,Sj=8,p=7/8,K=3) ==0

# verif modèle last
probaTsachantS(Tk=0,Sj=0,p=7/8,eps=0.1,K=3,modelEps="last")==0.9
probaTsachantS(Tk=1,Sj=0,p=7/8,eps=0.1,K=3)==0.1
probaTsachantS(Tk=2,Sj=0,p=7/8,eps=0.1,K=3)==0
probaTsachantS(Tk=4,Sj=4,p=2/3,eps=0.1,modelEps="last",K=4)==2/3



#probaTsachantS(Tk=0,Sj=0,p=7/8,eps=0.1,modelEps="equi",K=3)==0.9
#probaTsachantS(Tk=1,Sj=0,p=7/8,eps=0.1,modelEps="equi",K=3)==0.05
#probaTsachantS(Tk=3,Sj=2,p=7/8,eps=0.1,modelEps="equi",K=3)==0.05



#K nombre de tests
# p probabilité d'échouer au test au hasard
# eps probabilité de se tromper même si le seuil est supérieur
getMatrixTsachantS=function(p,K,eps=0,modelEps="last")
{
  res=matrix(NA,K+1,K+1)
  for(Tk in 1:(K+1))
  {
    for(Sj in 1:(K+1))
    {
      res[Sj,Tk]=probaTsachantS(Tk-1,Sj-1,p,eps=eps,K=K,modelEps=modelEps)
    }
  }
  return(res)
}
mat1=getMatrixTsachantS(2/3,3);round(mat1,digits=2) # en ligne s= 0, s=1,...
mat2=getMatrixTsachantS(2/3,3,eps=0.1,modelEps="last");round(mat2,digits=5) # en ligne s= 0, s=1,...
#mat3=getMatrixTsachantS(2/3,3,eps=0.1,modelEps="equi");round(mat3,digits=3) # en ligne s= 0, s=1,...

apply(mat1,1,sum)
apply(mat2,1,sum)
#apply(mat3,1,sum)
library(MASS)

round(ginv(getMatrixTsachantS(2/3,9)),digits=2)


# On definit probaS comme un vecteur de taille K contenant p(S in Ik)
# remarque probaS contient [p(s in I0),..., p(s in Ik)] et est donc de taille K +1
# probaS[1]=p(s in I0)
# pour probaS=rep(1/4,4), on a trois seuils d?finis, donc trois ?preuves: il est inutile de passer +
probaTinterS=function(probaS,Tk,Sj,p,K=NULL,eps=0,modelEps="none")
{
  return(probaS[Sj+1]*probaTsachantS(Tk=Tk,Sj=Sj,p=p,K=K,eps=eps,modelEps=modelEps))
}
probaTinterS(probaS=rep(1/4,4),Tk=3,Sj=3,p=7/8)== 7/8*0.25
probaTinterS(probaS=rep(1/4,4),Tk=0,Sj=3,p=7/8)+
probaTinterS(probaS=rep(1/4,4),Tk=1,Sj=3,p=7/8)+
probaTinterS(probaS=rep(1/4,4),Tk=2,Sj=3,p=7/8)+
probaTinterS(probaS=rep(1/4,4),Tk=3,Sj=3,p=7/8)==0.25


probaT=function(probaS,p=7/8)
{
  tVector=rep(NA,length(probaS))
  for(k in 0:(length(probaS)-1))
  {
    S=0
    for(j in 0:(length(probaS)-1))
    {
      S=S+probaTinterS(probaS,k,j,p)
    }
    tVector[k+1]=S
  }
  return(tVector)
}

pT=probaT(probaS=rep(1/4,4),p=7/8)
probaSnorm=dnorm(seq(0,9,length.out=10),mean=4.5,sd=1)
probaSnorm2=dnorm(seq(0,9,length.out=10),mean=4.5,sd=2)

plot(seq(0,9,length.out=100),dnorm(x=seq(0,9,length.out=100),mean=4.5,sd=1))
barplot(probaSnorm)
barplot(probaSnorm2)
barplot(probaT(probaS=rep(1/10,10),p=2/3),names.arg=0:9,main="P(T=...) \n supposant que s est equiréparti")
barplot(rep(1/10,10),names.arg=0:9,main="P(S) \n supposant que s est equiréparti")

barplot(probaT(probaS=probaSnorm,p=2/3),names.arg=0:9,main="P(T=...) \n supposant que s est normale")
barplot(probaT(probaS=probaSnorm2,p=2/3),names.arg=0:9,main="P(T=...) \n supposant que s est normale (2)")

#barplot(200*probaT(probaS=rep(1/10,10),p=2/3),names.arg=0:9,main="Nombre théorique des seuils observés (200 personnes) \n supposant que s est equiréparti")


# concentrations
conc=c(0.006,0.012,0.025,0.05,0.1,0.2,0.4,0.8,1.6)
plot(log(conc))
sum(pT)==1

pT[3]==probaTinterS(probaS=rep(1/4,4),Tk=2,Sj=0,p=7/8)+
  probaTinterS(probaS=rep(1/4,4),Tk=2,Sj=1,p=7/8)+
  probaTinterS(probaS=rep(1/4,4),Tk=2,Sj=2,p=7/8)+
  probaTinterS(probaS=rep(1/4,4),Tk=2,Sj=3,p=7/8)



probaSsachantT=function(probaS,Tk,Sj,p)
{
  int=probaTinterS(probaS,Tk,Sj,p)
  pT=probaT(probaS,p)[Tk+1]
  return(int/pT)
}

probaSsachantT(probaS=rep(1/10,10),Tk=0,Sj=0,p=2/3)
probaSsachantT(probaS=rep(1/10,10),Tk=1,Sj=1,p=2/3)

# Probabilit? que  s=2 sachant que T=1 (seuil plus faible que celui observ?)
probaSsachantT(probaS=rep(1/2,2),Tk=0,Sj=1,p=7/8)
probaSsachantT(probaS=rep(1/2,2),Tk=1,Sj=1,p=7/8) #sachant que T=1 (0 ou 1),la probabilit? que s=1 est de 1
probaSsachantT(probaS=rep(1/4,4),Tk=1,Sj=2,p=7/8)
probaSsachantT(probaS=rep(1/4,4),Tk=2,Sj=2,p=7/8)
probaSsachantT(probaS=rep(1/4,4),Tk=3,Sj=3,p=7/8)




# supposons ? pr?sent qu'on d?coupe en 6 intervalles avec la meme répartition (avec 5 seuils)
probaSsachantT(probaS=rep(1/6,6),Tk=0,Sj=0,p=7/8) # 0.87
probaSsachantT(probaS=rep(1/6,6),Tk=0,Sj=1,p=7/8) # 0.1093754
probaSsachantT(probaS=rep(1/6,6),Tk=0,Sj=2,p=7/8) # 0.01367193
probaSsachantT(probaS=rep(1/6,6),Tk=0,Sj=3,p=7/8) # 0.001708991
probaSsachantT(probaS=rep(1/6,6),Tk=0,Sj=4,p=7/8) # 0.0002136239

probaSsachantT(probaS=rep(1/6,6),Tk=0,Sj=1,p=7/8)
probaSsachantT(probaS=rep(1/6,6),Tk=4,Sj=4,p=7/8)
# la probabilit? d'avoir un seuil inf?rieur ? 2 sachant que T est inf?rieur ? 2 est de:
# P(S=1|T<2)+P(S=0|T<2)

# probaDeS sachant T : matrix
J=10
res=matrix(NA,J,J)
# a chaque colonne correspond une proba de seuils réels connaissant T
for(k in 0:(J-1))
{
  for(j in 0:(J-1))
  {
    res[j+1,k+1]=probaSsachantT(probaS=probaSnorm2,Tk=k,Sj=j,p=2/3)
  }
}
probaTnorm2=probaT(probaS=probaSnorm2,p=2/3)

# On recupere la distribution de seuil théorique comme ça
all(t(ginv(getMatrixTsachantS(2/3,9)))%*%probaTnorm2-probaSnorm2<1e-12)


pG1=sum(probaTnorm2[7:10])
probaSsachantG1=(
res[,10]*probaTnorm2[10]+res[,9]*probaTnorm2[9]+res[,8]*probaTnorm2[8]+res[,7]*probaTnorm2[7])/pG1
barplot(probaSsachantG1,names.arg=0:9)
#
pG2=sum(probaTnorm2[1:3])
probaSsachantG2=(
  res[,1]*probaTnorm2[1]+res[,2]*probaTnorm2[2]+res[,3]*probaTnorm2[3])/pG2
sum(probaSsachantG2)
barplot(probaSsachantG2,names.arg=0:9)


pT=probaT(probaS=probaSsachantG1,p=2/3)
barplot(pT,main="Proba du deuxieme seuil observé sachant G1")
46*pT

pT2=probaT(probaS=probaSsachantG2,p=2/3)
barplot(pT2,main="Proba du deuxieme seuil observé sachant G1")
43*pT2


# Utilisation sur les données TOM
#================================
library(openxlsx)
tom0=read.xlsx("Donnée_sensibilite_TOM.xlsx",sheet="Score sensibilité (0 à 6)")
# Remarque: dans tom, les seuils sont de 0 si aucun test réussi, 6 si tous les tests sont réussis....
# C'est l'exact inverse de ce qu'on a considéré
# Du coup, je transforme les données pour obtenir la même chose que nous:
tom=tom0
tom[,-1]=6-tom0[,-1]


# Distribution de la rep 1 pour obtenir les seuils réels
par(mfrow=c(2,3))
h1=hist(tom[,"Sucre-1"],main="Rep 1 (0=très sensible)",breaks=100,xlab="Seuil")
h1
hist(tom[,"Sucre-2"],main="Rep 2",breaks=100,xlab="Seuil")
hist(tom[,"Sucre-3"],main="Rep 3",breaks=100,xlab="Seuil")



hist(c(tom[,"Sucre-1"],tom[,"Sucre-2"],tom[,"Sucre-3"]),main="Toutes reps confondues",breaks=100,xlab="Seuil")
hist(apply(tom[,c("Sucre-1","Sucre-2","Sucre-3")],1,max),breaks=100,main="Seuil maximal observé sur les trois rep",xlab="Seuil")
hist(apply(tom[,c("Sucre-1","Sucre-2","Sucre-3")],1,median),breaks=100,main="Seuil médian observé sur les trois rep",xlab="Seuil")

# Distribution des seuils réels
tObsTomR1=summary(factor(tom[,"Sucre-1"]))/sum(summary(factor(tom[,"Sucre-1"])))
tObsTomR2=summary(factor(tom[,"Sucre-2"]))/sum(summary(factor(tom[,"Sucre-2"])))
tObsTomR3=summary(factor(tom[,"Sucre-3"]))/sum(summary(factor(tom[,"Sucre-3"])))

probaSeuilReelR1=t(ginv(getMatrixTsachantS(2/3,6)))%*%tObsTomR1
probaSeuilReelR2=t(ginv(getMatrixTsachantS(2/3,6)))%*%tObsTomR2
probaSeuilReelR3=t(ginv(getMatrixTsachantS(2/3,6)))%*%tObsTomR3
barplot((probaSeuilReelR1),beside=T,main="Seuil réel basé sur R1")
barplot((probaSeuilReelR2),beside=T,main="Seuil réel basé sur R2")
barplot((probaSeuilReelR3),beside=T,main="Seuil réel basé sur R3")

par(mfrow=c(2,2))
saveur="umami"
if(saveur=="sucre"){resTom=tom[,2:4]-apply(tom[,2:4],1,median)}
if(saveur=="sale"){resTom=tom[,5:7]-apply(tom[,5:7],1,median)}
if(saveur=="acide"){resTom=tom[,8:10]-apply(tom[,8:10],1,median)}
if(saveur=="amer"){resTom=tom[,11:13]-apply(tom[,11:13],1,median)}
if(saveur=="umami"){resTom=tom[,14:16]-apply(tom[,14:16],1,median)}

sum(resTom<0) /300 # la mediane (seuil supposé bon) est supérieur au score obtenu: la personne n'était peut etre pas concentrée ?
sum(resTom>0) /300 # la mediane (seuil supposé bon) est inférieur au score obtenu: le score est obtenu par chance
sum(resTom==0) /300
#MedianeJamaisNotee=apply(resTom,1,function(x) sum(x!=0))==3;s0=sum(MedianeJamaisNotee)
MedianeNonRepetee=apply(resTom,1,function(x) sum(x!=0))==2;s0=sum(MedianeNonRepetee)
MedianeRepeteeUneFois=apply(resTom,1,function(x) sum(x!=0))==1;s1=sum(MedianeRepeteeUneFois)
MedianeRepeteeDeuxFois=apply(resTom,1,function(x) sum(x!=0))==0; s2=sum(MedianeRepeteeDeuxFois)
c(s0,s1,s2)
diffMRF=unlist(as.vector(resTom[MedianeRepeteeUneFois,]))

hist(diffMRF[diffMRF!=0],main=paste0(saveur,": score des individus à la médiane répétée, \n (s0=",s0,", s1=",s1,", s2=",s2,")" ),breaks=50,xlab="Difference entre seuil et mediane du seuil")
#all=c(tom[,"Sucre-1"],tom[,"Sucre-2"],tom[,"Sucre-3"])
#tObsTom=summary(factor(all))/300
all=c(tom[,"Sucre-1"],tom[,"Sucre-2"])
tObsTom=summary(factor(all))/200
probaSeuilReel=t(ginv(getMatrixTsachantS(2/3,6)))%*%tObsTom
barplot((probaSeuilReel),beside=T,main="Seuil réel basé sur All")
epsilon=seq(0,0.1,length.out=100)
ssq=rep(NA,length(epsilon))
for(i in 1:length(epsilon))
{
 # matTSachantS_eps1=getMatrixTsachantS(p=2/3,K=6,eps=epsilon[i],modelEps="none")
  matTSachantS_eps1=getMatrixTsachantS(p=2/3,K=6,eps=epsilon[i],modelEps="last")
  matT_th=t(probaSeuilReel)%*%matTSachantS_eps1
  #ssq[i]=sum((matT_th-tObsTomR1)^2)+sum((matT_th-tObsTomR2)^2)+sum((matT_th-tObsTomR3)^2)
  #
  ssq[i]=sum((matT_th-tObsTomR3)^2)
}
plot(ssq)

matTSachantS0=getMatrixTsachantS(p=2/3,K=6,eps=epsilon[i],modelEps="none")



barplot(matT_th,beside=T)
barplot(tObsTomR1,beside=T)
barplot(tObsTomR2,beside=T)
barplot(tObsTomR3,beside=T)

hist(apply(tom[,c("Sucre-1","Sucre-2","Sucre-3")],1,median),breaks=100,main="Seuil médian observé sur les trois rep",xlab="Seuil")

